<?xml version="1.0" encoding="UTF-8" ?>
<class name="RayTracerBase" inherits="Node3D" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
		A custom raytracer node that traces rays against child mesh geometry with GPU/CPU backends and 6 debug visualization modes.
	</brief_description>
	<description>
		RayTracerBase is a [Node3D] that extracts triangle geometry from its [MeshInstance3D] children and traces rays against them using a high-performance BVH (Bounding Volume Hierarchy) acceleration structure.
		[b]This node does NOT use Godot's built-in physics or RayCast3D.[/b] It operates on raw triangle data with its own acceleration structures, making it suitable for custom ray queries (visibility, audio propagation, AI line-of-sight, etc.).
		[b]Key features:[/b]
		- Automatic triangle extraction from child [MeshInstance3D] nodes (recursive).
		- BVH acceleration with binned SAH (Surface Area Heuristic) construction.
		- CPU backend with multithreading, SIMD (SSE 4.1), and ray packet traversal.
		- GPU backend using a Vulkan compute shader on a local [RenderingDevice].
		- 6 debug visualization modes drawn with [ImmediateMesh].
		- Morton-code ray sorting for improved cache coherence.
		[b]Quick start:[/b]
		[codeblock]
		# 1. Add RayTracerBase as parent of your MeshInstance3D nodes.
		# 2. In _ready():
		$RayTracerBase.build_scene()

		# 3. Cast a single ray:
		var result = $RayTracerBase.cast_ray(origin, direction)
		if result["hit"]:
		    print("Hit at ", result["position"])

		# 4. Or visualize a grid of debug rays:
		$RayTracerBase.cast_debug_rays(cam.global_position, -cam.global_basis.z, 16, 12, 60.0)
		[/codeblock]
		[b]Performance notes:[/b]
		The BVH reduces ray-triangle intersection tests from O(N) to approximately O(log N). For a scene with 4000 triangles, expect around 5-12 triangle tests per ray instead of 4000. The GPU backend dispatches rays in parallel on the graphics card and is fastest for large batches (1000+ rays). The CPU backend uses a thread pool and SIMD to test 4 triangles simultaneously.
		[b]Architecture:[/b]
		Internally, RayTracerBase owns a [code]RayDispatcher[/code] that routes rays to the appropriate backend. The dispatcher manages a [code]RayScene[/code] (CPU BVH), a [code]GPURayCaster[/code] (Vulkan compute), and a [code]ThreadPool[/code]. Scene data is uploaded to the GPU as storage buffers (triangles + BVH nodes) and the compute shader performs parallel BVH traversal.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="build_scene">
			<return type="void" />
			<description>
				Extracts triangle geometry from all [MeshInstance3D] descendants (recursive) and builds the BVH acceleration structure.
				Must be called before [method cast_ray] or [method cast_debug_rays]. Call again whenever meshes are added, removed, or transformed.
				If the GPU backend is active and initialized, the scene is automatically uploaded to the GPU after building.
				Prints a summary to the output log:
				[codeblock]
				[RayTracerBase] Built scene: 4238 triangles, 2653 BVH nodes (depth 14) -- backend: GPU
				[/codeblock]
			</description>
		</method>
		<method name="cast_ray">
			<return type="Dictionary" />
			<param index="0" name="origin" type="Vector3" />
			<param index="1" name="direction" type="Vector3" />
			<description>
				Traces a single ray from [param origin] in [param direction] against the scene geometry. The direction is automatically normalized.
				Returns a [Dictionary] with the following keys:
				- [code]"hit"[/code] ([bool]): [code]true[/code] if the ray intersected any triangle.
				- [code]"position"[/code] ([Vector3]): The world-space intersection point. Only valid if [code]hit[/code] is [code]true[/code].
				- [code]"normal"[/code] ([Vector3]): The surface normal at the hit point (face normal, not interpolated).
				- [code]"distance"[/code] ([float]): The parametric distance [code]t[/code] along the ray. The hit point equals [code]origin + direction.normalized() * distance[/code].
				- [code]"prim_id"[/code] ([int]): The index of the triangle that was hit. [code]-1[/code] if no hit.
				[b]Example:[/b]
				[codeblock]
				var result = raytracer.cast_ray(camera.global_position, -camera.global_basis.z)
				if result["hit"]:
				    print("Hit triangle %d at distance %.2f" % [result["prim_id"], result["distance"]])
				    print("Surface normal: ", result["normal"])
				[/codeblock]
				[b]Note:[/b] Call [method build_scene] first. If the scene has not been built, the ray will miss everything.
			</description>
		</method>
		<method name="cast_debug_rays">
			<return type="void" />
			<param index="0" name="origin" type="Vector3" />
			<param index="1" name="forward" type="Vector3" />
			<param index="2" name="grid_w" type="int" />
			<param index="3" name="grid_h" type="int" />
			<param index="4" name="fov_degrees" type="float" />
			<description>
				Casts a grid of [code]grid_w * grid_h[/code] rays from [param origin] looking along [param forward], spread over a field of view of [param fov_degrees]. The results are drawn as colored lines in the 3D viewport using the current [member debug_draw_mode].
				The ray grid simulates a virtual camera: each ray corresponds to a pixel in a [code]grid_w x grid_h[/code] image. The [param fov_degrees] controls the horizontal field of view (vertical FOV is derived from the aspect ratio).
				[b]Typical usage (in _input or _process):[/b]
				[codeblock]
				if Input.is_action_just_pressed("cast_rays"):
				    var cam = get_viewport().get_camera_3d()
				    raytracer.cast_debug_rays(
				        cam.global_position,
				        -cam.global_basis.z,  # camera forward
				        16, 12,               # 16x12 ray grid (192 rays)
				        60.0                  # 60 degree FOV
				    )
				[/codeblock]
				Performance stats are printed to the output log after each call. Set [member debug_enabled] to [code]false[/code] to skip visualization entirely.
				[b]Note:[/b] [param grid_w] and [param grid_h] must be positive. [param fov_degrees] must be in the range (0, 180).
			</description>
		</method>
		<method name="clear_debug">
			<return type="void" />
			<description>
				Clears all debug visualization lines from the viewport. Call this to hide previously drawn rays.
			</description>
		</method>
		<method name="get_triangle_count" qualifiers="const">
			<return type="int" />
			<description>
				Returns the total number of triangles extracted from child meshes during the last [method build_scene] call. Returns [code]0[/code] if the scene has not been built.
			</description>
		</method>
		<method name="get_thread_count" qualifiers="const">
			<return type="int" />
			<description>
				Returns the number of threads in the CPU thread pool used for parallel ray casting. Typically equals the number of logical CPU cores.
			</description>
		</method>
		<method name="get_bvh_node_count" qualifiers="const">
			<return type="int" />
			<description>
				Returns the number of nodes in the BVH acceleration structure. Includes both internal (branch) nodes and leaf nodes. Returns [code]0[/code] if the scene has not been built.
			</description>
		</method>
		<method name="get_bvh_depth" qualifiers="const">
			<return type="int" />
			<description>
				Returns the maximum depth of the BVH tree. A deeper tree means more traversal steps per ray but tighter bounding boxes. Typical values are 10-20 for scenes with a few thousand triangles. Returns [code]0[/code] if the scene has not been built.
			</description>
		</method>
		<method name="get_gpu_available" qualifiers="const">
			<return type="bool" />
			<description>
				Returns [code]true[/code] if the GPU compute pipeline is fully initialized and the scene has been uploaded. When this returns [code]true[/code], rays will be dispatched to the GPU if [member backend] is set to [constant BACKEND_GPU] or [constant BACKEND_AUTO].
				Returns [code]false[/code] if: Vulkan is not available, the compute shader failed to compile, the GPU pipeline was not initialized, or the scene has not been uploaded yet.
			</description>
		</method>
		<method name="get_last_stats" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Returns a [Dictionary] containing performance statistics from the most recent [method cast_debug_rays] call. Useful for building custom HUD overlays or profiling.
				Keys:
				- [code]"rays_cast"[/code] ([int]): Total number of rays traced.
				- [code]"tri_tests"[/code] ([int]): Total ray-triangle intersection tests performed (CPU only).
				- [code]"bvh_nodes_visited"[/code] ([int]): Total BVH nodes traversed (CPU only).
				- [code]"hits"[/code] ([int]): Number of rays that hit geometry.
				- [code]"avg_tri_tests_per_ray"[/code] ([float]): Average triangle tests per ray (CPU only).
				- [code]"avg_nodes_per_ray"[/code] ([float]): Average BVH nodes visited per ray (CPU only).
				- [code]"hit_rate_percent"[/code] ([float]): Percentage of rays that hit geometry (0-100).
				- [code]"cast_time_ms"[/code] ([float]): Wall-clock time for the entire cast operation in milliseconds.
				[b]Note:[/b] [code]tri_tests[/code], [code]bvh_nodes_visited[/code], [code]avg_tri_tests_per_ray[/code], and [code]avg_nodes_per_ray[/code] are only populated on the CPU path. The GPU compute shader does not report per-ray traversal statistics.
			</description>
		</method>
		<method name="get_last_cast_ms" qualifiers="const">
			<return type="float" />
			<description>
				Returns the wall-clock time in milliseconds for the most recent [method cast_debug_rays] call. Includes ray generation, dispatch (CPU or GPU), and debug line drawing.
			</description>
		</method>
	</methods>
	<members>
		<member name="debug_enabled" type="bool" setter="set_debug_enabled" getter="get_debug_enabled" default="true">
			If [code]true[/code], [method cast_debug_rays] draws visualization lines in the viewport. If [code]false[/code], [method cast_debug_rays] returns immediately without casting or drawing anything. Useful for toggling debug visualization at runtime without removing the call.
		</member>
		<member name="debug_draw_mode" type="int" setter="set_debug_draw_mode" getter="get_debug_draw_mode" enum="RayTracerBase.DebugDrawMode" default="0">
			Selects which debug visualization style to use when [method cast_debug_rays] is called. See [enum DebugDrawMode] for descriptions of each mode.
		</member>
		<member name="debug_ray_miss_length" type="float" setter="set_debug_ray_miss_length" getter="get_debug_ray_miss_length" default="20.0">
			The length (in world units) of debug lines drawn for rays that miss all geometry. Longer values help visualize the ray direction further into the scene. Only affects [constant DRAW_RAYS] mode.
		</member>
		<member name="debug_normal_length" type="float" setter="set_debug_normal_length" getter="get_debug_normal_length" default="0.3">
			The length (in world units) of the cyan normal arrows drawn at hit points. Only affects [constant DRAW_RAYS] mode.
		</member>
		<member name="debug_heatmap_max_distance" type="float" setter="set_debug_heatmap_max_distance" getter="get_debug_heatmap_max_distance" default="50.0">
			The maximum distance for the distance heatmap color ramp. Rays hitting geometry beyond this distance are drawn in the darkest color. Only affects [constant DRAW_DISTANCE] mode.
		</member>
		<member name="debug_heatmap_max_cost" type="int" setter="set_debug_heatmap_max_cost" getter="get_debug_heatmap_max_cost" default="50">
			The maximum triangle test count for the cost heatmap color ramp. Rays requiring more tests than this value are drawn in the hottest color (red). Only affects [constant DRAW_HEATMAP] and [constant DRAW_OVERHEAT] modes.
		</member>
		<member name="debug_bvh_depth" type="int" setter="set_debug_bvh_depth" getter="get_debug_bvh_depth" default="0">
			Which BVH tree depth level to visualize in [constant DRAW_BVH] mode. [code]0[/code] draws the root bounding box, [code]1[/code] draws the two children, etc. Set to [code]-1[/code] to draw all leaf nodes. Higher values show progressively tighter bounding boxes.
		</member>
		<member name="use_bvh" type="bool" setter="set_use_bvh" getter="get_use_bvh" default="true">
			If [code]true[/code], rays are traced using the BVH acceleration structure (fast, O(log N) per ray). If [code]false[/code], rays test every triangle in the scene (brute force, O(N) per ray). Disabling the BVH is useful for correctness testing or benchmarking the acceleration structure's benefit.
		</member>
		<member name="backend" type="int" setter="set_backend" getter="get_backend" enum="RayTracerBase.BackendMode" default="0">
			Controls which ray tracing backend to use. See [enum BackendMode] for options. Changing this at runtime takes effect on the next [method cast_debug_rays] or [method cast_ray] call. The GPU backend is lazily initialized on first selection.
		</member>
	</members>
	<constants>
		<constant name="DRAW_RAYS" value="0" enum="DebugDrawMode">
			Classic ray visualization. Hit rays are drawn as green lines from origin to the hit point, with a yellow cross at the hit location and a cyan arrow showing the surface normal. Missed rays are drawn as red lines extending [member debug_ray_miss_length] units.
		</constant>
		<constant name="DRAW_NORMALS" value="1" enum="DebugDrawMode">
			Colors each ray by the surface normal at the hit point. The normal's X, Y, Z components are mapped to R, G, B (remapped from [-1,1] to [0,1]). Useful for verifying mesh winding and normal directions. Missed rays are drawn in dark gray.
		</constant>
		<constant name="DRAW_DISTANCE" value="2" enum="DebugDrawMode">
			Distance heatmap. Hit rays are colored on a ramp from white (close) through yellow and red to dark red (far). The ramp is scaled by [member debug_heatmap_max_distance]. Useful for visualizing scene depth.
		</constant>
		<constant name="DRAW_HEATMAP" value="3" enum="DebugDrawMode">
			Performance cost heatmap. Each ray is colored by how many triangle intersection tests it required: blue (few) through green, yellow, to red (many). The ramp is scaled by [member debug_heatmap_max_cost]. Useful for identifying BVH trouble spots where many triangles overlap.
		</constant>
		<constant name="DRAW_OVERHEAT" value="4" enum="DebugDrawMode">
			Like [constant DRAW_HEATMAP] but emphasizes expensive rays. Rays exceeding [member debug_heatmap_max_cost] triangle tests are highlighted in bright white. Useful for finding worst-case traversal paths.
		</constant>
		<constant name="DRAW_BVH" value="5" enum="DebugDrawMode">
			Draws the BVH bounding boxes as colored wireframes at the tree depth specified by [member debug_bvh_depth]. Each box is colored uniquely. Rays are still cast and drawn as a faint overlay. Useful for understanding the spatial partitioning and diagnosing BVH quality.
		</constant>
		<constant name="BACKEND_CPU" value="0" enum="BackendMode">
			Always use the CPU backend. Rays are dispatched across a thread pool with SIMD-accelerated triangle intersection (SSE 4.1) and 4-ray packet BVH traversal. Best for small ray counts or when GPU compute is unavailable.
		</constant>
		<constant name="BACKEND_GPU" value="1" enum="BackendMode">
			Prefer the GPU compute backend. A Vulkan compute shader performs parallel BVH traversal on the graphics card. The GPU is initialized lazily on first selection; if initialization fails, falls back to CPU silently. Best for large batches of rays (1000+).
		</constant>
		<constant name="BACKEND_AUTO" value="2" enum="BackendMode">
			Automatically select the best backend. Uses GPU if the compute pipeline is initialized and the scene is uploaded; otherwise uses CPU. The GPU is initialized on a best-effort basis when this mode is first selected.
		</constant>
	</constants>
</class>
